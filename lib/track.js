// Generated by CoffeeScript 1.10.0
(function() {
  var Logger, Path, Track, clone, deepMap, domain, fixPathPiece, fs, id3, mkdirp, objTypeof, ref, request, sformat,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require("fs");

  mkdirp = require("mkdirp");

  id3 = require("node-id3");

  domain = require("domain");

  request = require("request");

  Path = require("path");

  Logger = require("./log");

  Logger = new Logger();

  clone = require("clone");

  sformat = require("string-format");

  ref = require("./util"), objTypeof = ref.objTypeof, deepMap = ref.deepMap, fixPathPiece = ref.fixPathPiece;

  Track = (function() {
    function Track(uri, config, callback) {
      this.uri = uri;
      this.config = config;
      this.callback = callback;
      this.writeMetadata = bind(this.writeMetadata, this);
      this.downloadFile = bind(this.downloadFile, this);
      this.downloadCover = bind(this.downloadCover, this);
      this.createDirs = bind(this.createDirs, this);
      this.process = bind(this.process, this);
      this.track = {};
      this.file = {};
      this.retryCounter = 0;
    }

    Track.prototype.setSpotify = function(spotify) {
      this.spotify = spotify;
    };

    Track.prototype.process = function(uri, config, callback) {
      this.uri = uri;
      this.config = config;
      this.callback = callback;
      return this.spotify.get(this.uri, (function(_this) {
        return function(err, track) {
          if (err) {
            return typeof _this.callback === "function" ? _this.callback(err) : void 0;
          }
          _this.track = track;
          return _this.createDirs();
        };
      })(this));
    };

    Track.prototype.createDirs = function() {
      var _path, err, error, fields, fixStrg, pathFormat, stats, trackCopy;
      this.config.directory = Path.resolve(this.config.directory);
      pathFormat = this.config.folder && typeof this.config.folder === 'string' ? this.config.folder : "{artist.name} - {track.name}";
      trackCopy = clone(this.track);
      trackCopy.name = trackCopy.name.replace(/\//g, " - ");
      fixStrg = (function(_this) {
        return function(obj) {
          if (objTypeof(obj) === "[object String]") {
            obj = obj.replace(/\//g, "-");
            if (_this.config.onWindows) {
              obj = fixPathPiece(obj);
            }
          }
          return obj;
        };
      })(this);
      deepMap.call({
        fn: fixStrg
      }, trackCopy);
      fields = {
        track: trackCopy,
        artist: trackCopy.artist[0],
        album: trackCopy.album
      };
      fields.album.year = fields.album.date.year;
      try {
        _path = sformat(pathFormat, fields);
      } catch (error) {
        err = error;
        Logger.Error("Invalid path format: " + err);
        throw err;
      }
      if (!_path.endsWith(".mp3")) {
        _path += ".mp3";
      }
      this.file.path = Path.join(this.config.directory, _path);
      this.file.directory = Path.dirname(this.file.path);
      if (fs.existsSync(this.file.path)) {
        stats = fs.statSync(this.file.path);
        if (stats.size !== 0) {
          Logger.Info("Already downloaded: " + this.track.artist[0].name + " - " + this.track.name);
          return typeof this.callback === "function" ? this.callback() : void 0;
        }
      }
      if (!fs.existsSync(this.file.directory)) {
        mkdirp.sync(this.file.directory);
      }
      this.downloadCover();
      return this.downloadFile();
    };

    Track.prototype.downloadCover = function() {
      var coverPath, coverUrl;
      coverPath = this.file.path + ".jpg";
      coverUrl = "" + this.track.album.coverGroup.image[2].uri;
      request.get(coverUrl).on("error", (function(_this) {
        return function(err) {
          return Logger.Error("Error while downloading cover: " + err);
        };
      })(this)).pipe(fs.createWriteStream(coverPath));
      return Logger.Log("Cover downloaded: " + this.track.artist[0].name + " - " + this.track.name);
    };

    Track.prototype.downloadFile = function() {
      var d;
      Logger.Log("Downloading: " + this.track.artist[0].name + " - " + this.track.name);
      d = domain.create();
      d.on("error", (function(_this) {
        return function(err) {
          Logger.Error("Error received: " + err);
          if (("" + err).indexOf("Rate limited") > -1) {
            Logger.Info(err + " ... { Retrying in 10 seconds }");
            if (_this.retryCounter < 2) {
              _this.retryCounter++;
              return setTimeout(_this.downloadFile, 10000);
            } else {
              Logger.Error("Unable to download song. Continuing");
              return typeof _this.callback === "function" ? _this.callback() : void 0;
            }
          } else {
            return typeof _this.callback === "function" ? _this.callback() : void 0;
          }
        };
      })(this));
      return d.run((function(_this) {
        return function() {
          var err, error, out;
          out = fs.createWriteStream(_this.file.path);
          try {
            return _this.track.play().pipe(out).on("finish", function() {
              Logger.Log("Done: " + _this.track.artist[0].name + " - " + _this.track.name);
              return _this.writeMetadata();
            });
          } catch (error) {
            err = error;
            Logger.Error("Error while downloading track! " + err);
            return typeof _this.callback === "function" ? _this.callback() : void 0;
          }
        };
      })(this));
    };

    Track.prototype.writeMetadata = function() {
      var meta;
      meta = {
        artist: this.track.artist[0].name,
        album: this.track.album.name,
        title: this.track.name,
        year: "" + this.track.album.date.year,
        trackNumber: "" + this.track.number,
        image: this.file.path + ".jpg"
      };
      id3.write(meta, this.file.path);
      fs.unlink(meta.image);
      return typeof this.callback === "function" ? this.callback() : void 0;
    };

    return Track;

  })();

  module.exports = Track;

}).call(this);
